package net.ccbluex.liquidbounce.features.module.modules.exploit

import io.netty.buffer.Unpooled
import net.ccbluex.liquidbounce.LiquidBounce
import net.ccbluex.liquidbounce.event.EventTarget
import net.ccbluex.liquidbounce.event.PacketEvent
import net.ccbluex.liquidbounce.event.UpdateEvent
import net.ccbluex.liquidbounce.event.WorldEvent
import net.ccbluex.liquidbounce.features.module.Module
import net.ccbluex.liquidbounce.features.module.ModuleCategory
import net.ccbluex.liquidbounce.features.module.ModuleInfo
import net.ccbluex.liquidbounce.features.module.modules.world.Scaffold
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.Notification
import net.ccbluex.liquidbounce.ui.client.hud.element.elements.NotifyType
import net.ccbluex.liquidbounce.utils.ClientUtils
import net.ccbluex.liquidbounce.utils.PacketUtils
import net.ccbluex.liquidbounce.utils.timer.MSTimer
import net.ccbluex.liquidbounce.value.BoolValue
import net.ccbluex.liquidbounce.value.IntegerValue
import net.ccbluex.liquidbounce.value.ListValue
import net.minecraft.init.Items
import net.minecraft.network.Packet
import net.minecraft.network.PacketBuffer
import net.minecraft.network.play.INetHandlerPlayServer
import net.minecraft.network.play.client.*
import net.minecraft.network.play.client.C03PacketPlayer.*
import net.minecraft.network.play.server.S08PacketPlayerPosLook
import java.io.ByteArrayOutputStream
import java.io.DataOutputStream
import java.io.IOException
import java.util.*
import kotlin.math.sqrt

@ModuleInfo(name = "Disabler", category = ModuleCategory.EXPLOIT,description = "114514")
class Disabler : Module() {
    private val modeValue = ListValue("Mode", arrayOf("Blocksmc","Simple Velocity","VulcanCombat", "HuaYuTingTest","FakeLag","Hypixel"), "MinePlexCombat")
    private val debug = BoolValue("Debug", false)
    private val fakeLagPosValue = BoolValue("FakeLagPosition", false)
    private val fakeLagBlockValue = BoolValue("FakeLagBlock", false)
    private val fakeLagAttackValue = BoolValue("FakeLagAttack", false)
    private val fakeLagSpoofValue = BoolValue("FakeLagC03Spoof", false)
    private val lagDelayValue = IntegerValue("LagDelay", 0, 0, 2000)
    private val lagDurationValue = IntegerValue("LagDuration", 200, 100, 1000)
    private val lobbycheck = BoolValue("BlocksMCLobbyCheck", true)
    private val verusSlientFlagApplyValue = BoolValue("VerusSlientFlagApply", false)
    private val verusBufferSizeValue = IntegerValue("VerusBufferSize", 300, 0, 1000)
    private val verusRepeatTimesFightingValue = IntegerValue("Verus-RepeatTimesFighting", 1, 1, 5)
    private val verusRepeatTimesValue = IntegerValue("Verus-RepeatTimes", 1, 1, 5)
    private val verusFlagDelayValue = IntegerValue("Verus-FlagDelay", 40, 35, 60)

    private var vulTickCounterUID = 0
    private val packetBuffer = LinkedList<Packet<INetHandlerPlayServer>>()
    private val lagTimer = MSTimer()
    private var verus2Stat = false
    private var currentTrans = 0
    private var memeTick = 0
    private var isSent = false
    private val fakeLagDelay = MSTimer()
    private val fakeLagDuration = MSTimer()
    private var modified = false
    private var counter = 0
    private val timer2 = MSTimer()
    private var cancel = false
    private val packets = ArrayList<Packet<*>>()

    private val repeatTimes: Int
        get() = if(LiquidBounce.combatManager.inCombat) { verusRepeatTimesFightingValue.get() } else { verusRepeatTimesValue.get() }

    private val c0fs = mutableListOf<Packet<INetHandlerPlayServer>>()
    private val c00s = mutableListOf<Packet<INetHandlerPlayServer>>()

    private fun shouldNotRun(): Boolean {
        if (lobbycheck.get()) {
            if (mc.thePlayer == null) {
                return true
            }
            if (mc.thePlayer.inventory == null) {
                return true
            }
            if (mc.thePlayer.inventory.hasItem(Items.compass)) {
                return true
            }
        }
        return mc.thePlayer == null || mc.thePlayer.ticksExisted <= 5
    }

    override fun onEnable() {
        if(modeValue.equals("VulcanCombat")){

            vulTickCounterUID = -25767
            LiquidBounce.hud.addNotification(
                Notification(
                    name,
                    "AntiCheat Will disabled when u rejoin the game!",
                    NotifyType.WARNING)
            )
            debugMessage("VulcanCombat Disabler §c§lONLY §r§awork when you rejoined the server!")
        }
        reset()
    }

    override fun onDisable() {
        when (modeValue.get().toLowerCase()) {
            "fakelag" -> {
                for (packet in packetBuffer) {
                    PacketUtils.sendPacketNoEvent(packet)
                }
                packetBuffer.clear()
            }
            "hypixel" -> {
                counter = 0
            }
        }
    }


    @EventTarget
    fun onWorld(event: WorldEvent) {
        if(modeValue.equals("VulcanCombat")) {
            currentTrans = 0
            packetBuffer.clear()
            lagTimer.reset()
            vulTickCounterUID = -25767
        }
        reset()
    }

    private fun reset() {
        memeTick = 0
        currentTrans = 0
        verus2Stat = false
        packetBuffer.clear()
        fakeLagDelay.reset()
        fakeLagDuration.reset()
    }

    @EventTarget
    fun onUpdate(event: UpdateEvent) {
        when (modeValue.get().toLowerCase()) {

            "fakelag" -> {
                if (!fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) fakeLagDuration.reset()
                // Send
                if (fakeLagDuration.hasTimePassed(lagDurationValue.get().toLong())) {
                    fakeLagDelay.reset()
                    fakeLagDuration.reset()
                    for (packet in packetBuffer) {
                        PacketUtils.sendPacketNoEvent(packet)
                    }
                    debugMessage("Release buf(size=${packetBuffer.size})")
                    isSent = true
                    packetBuffer.clear()
                }
            }
            "vulcancombat"->{
                if(lagTimer.hasTimePassed(5000L) && packetBuffer.size > 4) {
                    lagTimer.reset()
                    while (packetBuffer.size > 4) {
                        PacketUtils.sendPacketNoEvent(packetBuffer.poll())
                    }
                }
            }
            "blocksmc" -> {
                if(fakeLagDelay.hasTimePassed(490L)) {
                    fakeLagDelay.reset()
                    if(packetBuffer.isNotEmpty()) {
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            PacketUtils.sendPacketNoEvent(packet)
                        }
                        debugMessage("RELEASE")
                    } else {
                        debugMessage("RELEASE BUT EMPTY")
                    }
                }
            }
        }
    }
    @EventTarget
    fun onPacket(event: PacketEvent) {
        val scaffold = LiquidBounce.moduleManager.getModule(Scaffold::class.java) as Scaffold
        val packet = event.packet

        when (modeValue.get().toLowerCase()) {
            "basic" -> {
                if (packet is C0FPacketConfirmTransaction || packet is C00PacketKeepAlive) {
                    event.cancelEvent()
                }
            }

            "vulcancombat"->{
                val packet = event.packet
                if (packet is C0FPacketConfirmTransaction) {
                    if (Math.abs((Math.abs((packet.uid).toInt()).toInt() - Math.abs(vulTickCounterUID.toInt()).toInt()).toInt()) <= 4) {
                        vulTickCounterUID = (packet.uid).toInt()
                        packetBuffer.add(packet)
                        event.cancelEvent()
                        debugMessage("C0F-PingTickCounter IN ${packetBuffer.size}")
                    }else if (Math.abs((Math.abs((packet.uid).toInt()).toInt() - 25767).toInt()) <= 4) {
                        vulTickCounterUID = (packet.uid).toInt()
                        debugMessage("C0F-PingTickCounter RESETED")
                    }
                 }
                }
            "oldmatrix" -> {
                if (packet is C03PacketPlayer && !(packet is C04PacketPlayerPosition||packet is C05PacketPlayerLook ||packet is C06PacketPlayerPosLook)) {
                    event.cancelEvent()
                }
                if (packet is C02PacketUseEntity || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook ||
                    packet is C06PacketPlayerPosLook || packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement ||
                    packet is C0APacketAnimation || packet is C0BPacketEntityAction) {
                    event.cancelEvent()
                    packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                }
            }

            "Simple Velocity" -> {
                if (packet is C03PacketPlayer) {
                    packet.y += 0.135
                    debugMessage("Velocity Packet C03")
                }
            }

            "huayutingtest" -> if (packet is C03PacketPlayer && mc.thePlayer.ticksExisted % 15 == 0) {
                try {
                    val b = ByteArrayOutputStream()
                    val _out = DataOutputStream(b)
                    _out.writeUTF(mc.thePlayer.gameProfile.getName())
                    val buf = PacketBuffer(Unpooled.buffer())
                    buf.writeBytes(b.toByteArray())
                    mc.netHandler.addToSendQueue(C17PacketCustomPayload("aac5:resetFlags", buf))
                } catch (e: IOException) {
                }
            }
            "blocksmc" -> {
                if (this.shouldNotRun()) {
                    this.packetBuffer.clear()
                    return
                }
                if(packet is C0FPacketConfirmTransaction) {
                    packetBuffer.add(packet)
                    event.cancelEvent()
                    if(packetBuffer.size > verusBufferSizeValue.get()) {
                        if(!verus2Stat) {
                            verus2Stat = true
                            LiquidBounce.hud.addNotification(
                                Notification(
                                    name,
                                    "AntiCheat Disabled!",
                                    NotifyType.SUCCESS)
                            )
                        }
                        val packet = packetBuffer.poll()
                        repeat(repeatTimes) {
                            PacketUtils.sendPacketNoEvent(packet)
                        }
                    }
                } else if(packet is C03PacketPlayer) {
                    if((mc.thePlayer.ticksExisted % verusFlagDelayValue.get() == 0) && (mc.thePlayer.ticksExisted > verusFlagDelayValue.get() + 1) && !modified) {
                        debugMessage("C03 MODIFY")
                        modified = true
                        packet.y -= 11.4514 // 逸一时，误一世
                        packet.onGround = false
                    }
                } else if (packet is S08PacketPlayerPosLook && verusSlientFlagApplyValue.get()) {
                    val x = packet.x - mc.thePlayer.posX
                    val y = packet.y - mc.thePlayer.posY
                    val z = packet.z - mc.thePlayer.posZ
                    val diff = sqrt(x * x + y * y + z * z)
                    if (diff <= 8) {
                        event.cancelEvent()
                        // why didnt they check flag apply delay? LMAO
                        debugMessage("FLAG APPLY")
                        PacketUtils.sendPacketNoEvent(C06PacketPlayerPosLook(packet.x, packet.y, packet.z, packet.getYaw(), packet.getPitch(), true))
                    }
                }

                if (mc.thePlayer != null && mc.thePlayer.ticksExisted <= 7) {
                    fakeLagDelay.reset()
                    packetBuffer.clear()
                }
            }

            "fakelag" -> {
                if (fakeLagDelay.hasTimePassed(lagDelayValue.get().toLong())) {
                    if (isSent && fakeLagSpoofValue.get()) {
                        PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        if (lagDurationValue.get() >= 300) PacketUtils.sendPacketNoEvent(C03PacketPlayer(true))
                        isSent = false
                    }
                    if (packet is C00PacketKeepAlive || packet is C0FPacketConfirmTransaction) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if (fakeLagAttackValue.get() && (packet is C02PacketUseEntity || packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                        if (packet is C0APacketAnimation) return
                    }
                    if (fakeLagBlockValue.get() && (packet is C07PacketPlayerDigging || packet is C08PacketPlayerBlockPlacement || packet is C0APacketAnimation)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                    if (fakeLagPosValue.get() && (packet is C03PacketPlayer || packet is C04PacketPlayerPosition || packet is C05PacketPlayerLook || packet is C06PacketPlayerPosLook || packet is C0BPacketEntityAction)) {
                        event.cancelEvent()
                        packetBuffer.add(packet as Packet<INetHandlerPlayServer>)
                    }
                }
            }
            "hypixel" -> {
                // Strafe
                if (packet is C03PacketPlayer || packet is C04PacketPlayerPosition || packet is C06PacketPlayerPosLook) {
                    if (mc.thePlayer.ticksExisted < 50) {
                        event.cancelEvent()
                    }
                }
                if (packet is C03PacketPlayer) {
                    if (!packet.isMoving && !mc.thePlayer.isUsingItem) {
                        event.cancelEvent()
                    }
                    if (cancel) {
                        if (!timer2.hasTimeElapsed(400, false)) {
                            if (!scaffold.state) {
                                event.cancelEvent()
                                packets.add(packet)
                            } else {
                                packets.clear()
                                cancel = false
                            }
                        }
                    }
                }
            }
        }
    }

    private fun debugMessage(str: String) {
        if (debug.get()) {
            ClientUtils.displayChatMessage(" [NobleFull] $str")
        }
    }




    override val tag: String
        get() = modeValue.get()
}
